import os
import sys
sys.path.append(os.getcwd())
sys.path.append(os.path.join(
    os.getcwd(), 'external_libraries', 'MCAP_python_mpc'))

import numpy as np
import sympy as sp
from dataclasses import dataclass

from external_libraries.MCAP_python_mpc.python_mpc.nonlinear_mpc import NonlinearMPC_TwiceDifferentiable
from python_mpc.nonlinear_mpc_deploy import NonlinearMPC_Deploy

from sample.simulation_manager.visualize.simulation_plotter import SimulationPlotter
from external_libraries.MCAP_python_mpc.sample.nonlinear.support.interpolate_path import interpolate_path_csv


def create_plant_model():
    wheel_base = sp.Symbol('wheel_base', real=True,
                           positive=True, nonzero=True)
    delta_time = sp.Symbol('delta_time', real=True,
                           positive=True, nonzero=True)

    px, py, q0, q3 = sp.symbols('px py q0 q3', real=True)
    v, delta = sp.symbols('v delta', real=True)

    X = sp.Matrix([px, py, q0, q3])
    U = sp.Matrix([v, delta])

    dtheta = (v / wheel_base) * sp.tan(delta)
    half = sp.Rational(1, 2)
    dq0 = sp.cos(dtheta * delta_time * half)
    dq3 = sp.sin(dtheta * delta_time * half)

    q0_next = q0 * dq0 - q3 * dq3
    q3_next = q0 * dq3 + q3 * dq0

    f = sp.Matrix([
        px + delta_time * v * (2 * q0**2 - 1),
        py + delta_time * v * (2 * q3 * q0),
        q0_next,
        q3_next
    ])
    fxu = sp.simplify(f)

    Y = sp.Matrix([px, py, q0, q3])
    hx = Y

    return fxu, hx, X, U


@dataclass
class Parameters:
    wheel_base: float = 2.8  # [m]
    delta_time: float = 0.1  # [s]


def main():
    # simulation setup
    simulation_time = 60.0
    delta_time = 0.1
    Number_of_Delay = 0

    fxu, hx, x_syms, u_syms = create_plant_model()

    OUTPUT_SIZE = hx.shape[0]

    # Prediction horizon
    Np = 10

    # define parameters
    state_space_parameters = Parameters()

    # input bounds
    U_min = np.array([[-1.0], [-1.5]])
    U_max = np.array([[1.0], [1.5]])

    # weights
    Weight_U = np.array([0.05, 0.05])
    Weight_Y = np.array([1.0, 1.0, 1.0, 1.0])

    Q_ekf = np.diag([1.0, 1.0, 1.0, 1.0])
    R_ekf = np.diag([1.0, 1.0, 1.0, 1.0])

    # Reference
    # "office_area_RRT_path_data.csv" is generated by sample/office_area_path_plan_demo.py
    # in "https://github.com/Modeling-Coding-Automation-Project/MCAP_python_navigation"
    times, px_reference, py_reference, yaw_reference = interpolate_path_csv(
        input_path="./external_libraries/MCAP_python_mpc/sample/nonlinear/support/office_area_RRT_path_data.csv",
        delta_time=delta_time,
        total_time=simulation_time
    )

    q0_reference = np.cos(yaw_reference * 0.5)
    q3_reference = np.sin(yaw_reference * 0.5)

    # Nonlinear MPC object
    X_initial = np.array([[px_reference[0, 0]],
                          [py_reference[0, 0]],
                          [q0_reference[0, 0]],
                          [q3_reference[0, 0]]])

    nonlinear_mpc = NonlinearMPC_TwiceDifferentiable(
        delta_time=state_space_parameters.delta_time,
        X=x_syms,
        U=u_syms,
        X_initial=X_initial,
        fxu=fxu,
        hx=hx,
        parameters_struct=state_space_parameters,
        Np=Np,
        Weight_U=Weight_U,
        Weight_Y=Weight_Y,
        U_min=U_min,
        U_max=U_max,
        Q_kf=Q_ekf,
        R_kf=R_ekf,
        Number_of_Delay=Number_of_Delay,
    )

    # You can create cpp header which can easily define MPC as C++ code
    deployed_file_names = NonlinearMPC_Deploy.generate_Nonlinear_MPC_cpp_code(
        nonlinear_mpc)
    print(deployed_file_names)

    x_true = X_initial
    u = np.array([[0.0], [0.0]])

    nonlinear_mpc.set_solver_max_iteration(5)

    plotter = SimulationPlotter()

    y_measured = np.array([[0.0], [0.0], [0.0], [0.0]])
    y_store = [y_measured] * (Number_of_Delay + 1)
    delay_index = 0

    # simulation
    for i in range(round(simulation_time / delta_time)):
        # system response
        if i > 0:
            u = np.copy(u_from_mpc)

        x_true = nonlinear_mpc.kalman_filter.state_function(
            x_true, u, state_space_parameters)

        q_norm = np.sqrt(x_true[2, 0]**2 + x_true[3, 0]**2)
        x_true[2, 0] = x_true[2, 0] / q_norm
        x_true[3, 0] = x_true[3, 0] / q_norm

        y_store[delay_index] = nonlinear_mpc.kalman_filter.measurement_function(
            x_true, state_space_parameters)

        # system delay
        delay_index += 1
        if delay_index > Number_of_Delay:
            delay_index = 0

        y_measured = y_store[delay_index]

        # Reference for NMPC
        reference = np.zeros((OUTPUT_SIZE, Np))
        for j in range(Np):
            index = i + j
            if index >= px_reference.shape[0]:
                index = px_reference.shape[0] - 1

            reference[0, j] = px_reference[index, 0]
            reference[1, j] = py_reference[index, 0]
            reference[2, j] = q0_reference[index, 0]
            reference[3, j] = q3_reference[index, 0]

        u_from_mpc = nonlinear_mpc.update_manipulation(reference, y_measured)

        # monitoring
        solver_iteration = nonlinear_mpc.get_solver_step_iterated_number()

        px_ref = reference[0, 0]
        py_ref = reference[1, 0]
        yaw_ref = 2.0 * np.arctan2(reference[3, 0], reference[2, 0])
        px_measured = y_measured[0, 0]
        py_measured = y_measured[1, 0]
        yaw_measured = 2.0 * np.arctan2(y_measured[3, 0], y_measured[2, 0])

        v = u_from_mpc[0, 0]
        delta = u_from_mpc[1, 0]

        plotter.append_name(px_ref, "px_ref")
        plotter.append_name(py_ref, "py_ref")
        plotter.append_name(yaw_ref, "yaw_ref")
        plotter.append_name(px_measured, "px_measured")
        plotter.append_name(py_measured, "py_measured")
        plotter.append_name(yaw_measured, "yaw_measured")
        plotter.append_name(v, "v")
        plotter.append_name(delta, "delta")
        plotter.append_name(solver_iteration, "solver_iteration")

    plotter.assign("px_ref", column=0, row=0, position=(0, 0),
                   x_sequence=times, label="px_ref")
    plotter.assign("px_measured", column=0, row=0, position=(0, 0),
                   x_sequence=times, label="px_measured")
    plotter.assign("py_ref", column=0, row=0, position=(1, 0),
                   x_sequence=times, label="py_ref")
    plotter.assign("py_measured", column=0, row=0, position=(1, 0),
                   x_sequence=times, label="py_measured")
    plotter.assign("yaw_ref", column=0, row=0, position=(2, 0),
                   x_sequence=times, label="yaw_ref")
    plotter.assign("yaw_measured", column=0, row=0, position=(2, 0),
                   x_sequence=times, label="yaw_measured")
    plotter.assign("v", column=0, row=0, position=(0, 1),
                   x_sequence=times, label="v")
    plotter.assign("delta", column=0, row=0, position=(1, 1),
                   x_sequence=times, label="delta")
    plotter.assign("solver_iteration", column=0, row=0, position=(2, 1),
                   x_sequence=times, label="solver_iteration")

    plotter.plot()


if __name__ == "__main__":
    main()
